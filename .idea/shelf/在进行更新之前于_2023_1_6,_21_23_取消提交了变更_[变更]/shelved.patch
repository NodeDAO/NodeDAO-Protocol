Index: src/interfaces/IBeaconOracle.sol
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.7;\n\n/**\n  * @title Beacon Oracle and Dao\n  *\n  * BeaconOracle data acquisition and verification\n  * Dao management\n  */\ninterface IBeaconOracle {\n    // TODO:@renshiwei 2023/1/5 description: verifyNftValue function\n    function verifyNftValue(bytes memory pubkey, uint256 validatorBalance, uint256 nftTokenID) external view returns (bool);\n\n    // Is a member of the dao\n    function isDaoMember(address _daoMember) external view returns (bool);\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/interfaces/IBeaconOracle.sol b/src/interfaces/IBeaconOracle.sol
--- a/src/interfaces/IBeaconOracle.sol	(revision 2ae63f478b83c9be780b7f24cbdce90b62da1919)
+++ b/src/interfaces/IBeaconOracle.sol	(date 1673011198322)
@@ -8,10 +8,11 @@
   * Dao management
   */
 interface IBeaconOracle {
-    // TODO:@renshiwei 2023/1/5 description: verifyNftValue function
-    function verifyNftValue(bytes memory pubkey, uint256 validatorBalance, uint256 nftTokenID) external view returns (bool);
 
-    // Is a member of the dao
-    function isDaoMember(address _daoMember) external view returns (bool);
+    // verifyNftValue
+    function verifyNftValue(bytes32[] memory proof, bytes32 leaf) external view returns (bool);
+
+    // Is a reporter
+    function isReporter(address _daoMember) external view returns (bool);
 
 }
Index: src/LiquidStaking.sol
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.7;\n\nimport \"openzeppelin-contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"openzeppelin-contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport \"src/interfaces/INodeOperatorsRegistry.sol\";\nimport \"src/interfaces/ILiquidStaking.sol\";\n\ncontract LiquidStaking is Initializable, UUPSUpgradeable, ReentrancyGuardUpgradeable, OwnableUpgradeable, PausableUpgradeable, ILiquidStaking{\n    \n    bytes private withdrawalCredentials;\n    uint256 private totalBeaconValidators ;\n    bytes32 private nodeRankingCommitment ;\n    uint256 public constant depositSize = 32 ether;\n    uint256 private depositFeeRate ;\n    uint256 public constant totalBasisPoints = 10000;\n    uint256 public constant DEPOSIT_SIZE = 32 ether;\n    uint256 private bufferedEtherPosition ;\n    uint256 private transientEtherPosition ;\n    uint256 private beaconEtherPosition ;\n\n    mapping(uint256 => uint256) public operatorPoolBalances;\n\n    event DepositReceived(address indexed from, uint256 amount, address indexed _referral);\n    event ELRewardsReceived(uint256 balance);\n    event EtherDeposited(address from, uint256 balance, uint256 height);\n\n    INodeOperatorsRegistry iNodeOperatorRegistry;\n    // function initialize( bytes memory withdrawalCreds, address _validatorNftAddress , address _nETHAddress, address _nodeOperatorRegistry  ) external initializer {\n    function initialize( bytes memory withdrawalCreds, address _nodeOperatorRegistry ) external initializer {\n        __Ownable_init(); \n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        withdrawalCredentials = withdrawalCreds;\n        iNodeOperatorRegistry = INodeOperatorsRegistry(_nodeOperatorRegistry) ;\n        // IVNFT vnft = IVNFT(_validatorNftAddress) ;\n        // INETH iNETH = INETH(_nETHAddress) ;\n    }\n\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n    function stakeETH(address _referral, uint256 _node_operator) external payable nonReentrant {\n        \n        require(iNodeOperatorRegistry.isTrustedOperator(_node_operator) == true , \"The message sender is not part of Trusted KingHash Operators\");\n        require(msg.value != 0, \"Stake amount must not be Zero\");\n        require(msg.value >= 100 wei, \"Stake amount must be minimum  100 wei\");\n        require(_referral != address(0x0), \"Referral address must be provided\") ;\n\n        uint256 depositNet ;\n        if(getDepositFeeRate() == 0 ){\n            depositNet = msg.value;\n        }\n        else {         \n            depositNet = getDepositFeeRate() / totalBasisPoints * msg.value ;\n        }\n        addBufferedEtherPosition(depositNet) ;\n        addToOperatorBalance(_node_operator, depositNet);\n        // iNETH.mint(msg.sender, depositNet);\n\n        emit DepositReceived(msg.sender, msg.value, _referral);\n    }\n\n    function mintNFT(bytes calldata data) external payable nonReentrant {\n        require(msg.value >= DEPOSIT_SIZE , \"Stake amount must be minimum 32 ether\");\n        // require(iNodeOperatorRegistry.checkOperator(_node_operator) == true , \"The message sender is not part of KingHash Operators\");\n        // eth32Route();\n     }\n\n    //  function unstake()nonReentrant whenNotPaused {}\n\n    /*  function wrapNFT(){\n        checkWrapNftIsValid\n        checkTransferredkETH\n        verifyNFTValue\n        addUserGasHeight\n        burnKETH\n        transferNFT\n    } */ \n\n    /*  function unwrapNFT(){\n            require(iNodeOperatorRegistry.isTrustedOperator(_node_operator) == true , \"The message sender is not part of Trusted KingHash Operators\");\n            verifyNFTValue from Oracle\n            transferFromNFT from VNFT\n            removeUserGasHeight from EexceutionVault\n            mintKETH from NETH\n    }*/ \n\n    //  function burnNFT(){}\n\n\n    function handleOracleReport(uint256 data, bytes32 nodeRankingCommitment) external override{\n       \n    }\n    \n\n\n    function getTotalPooledEther() external override returns(uint256){\n        return bufferedEtherPosition + transientEtherPosition + beaconEtherPosition ; \n    }\n\n    function getChainUpFromNodeRegistry() internal pure returns(uint256) {\n         return  1 ;\n    }\n\n    function addBufferedEtherPosition(uint256 _amt) internal {\n        bufferedEtherPosition += _amt ;\n    }\n\n    function subtractBufferedEtherPosition(uint256 _amt) internal {\n        bufferedEtherPosition -= _amt ;\n    }\n\n    function addTransientEtherPosition(uint256 _amt) internal {\n        transientEtherPosition += _amt ;\n    }\n\n    function subtractTransientEtherPosition(uint256 _amt) internal {\n        transientEtherPosition -= _amt ;\n    }\n\n    function addBeaconEtherPosition(uint256 _amt) internal {\n        beaconEtherPosition += _amt ;\n    }\n\n    function subtractBeaconEtherPosition(uint256 _amt) internal {\n        beaconEtherPosition -= _amt ;\n    }\n\n    function setDepositFeeRate(uint256 _rate) external onlyOwner {\n        depositFeeRate = _rate ;\n    }\n\n    function getDepositFeeRate() internal view returns(uint256) {\n        return depositFeeRate ;\n    }\n    \n    function addToOperatorBalance(uint256 operator, uint256 amount) internal {\n        // require(iNodeOperatorRegistry.checkTrustOperator(_node_operator) == true , \"The message sender is not part of KingHash Operators\");\n        operatorPoolBalances[operator] += amount;\n    }\n\n    /* function getFreeEther() returns(uint256){\n    //  consider EL rewards, Buffered/Deposited Ether\n    return bufferedEtherPosition +  computeELRewards() ;\n    } */\n\n    /* function computeELRewards() internal returns (uint256) {\n          return 0;\n      }*/\n\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/LiquidStaking.sol b/src/LiquidStaking.sol
--- a/src/LiquidStaking.sol	(revision 2ae63f478b83c9be780b7f24cbdce90b62da1919)
+++ b/src/LiquidStaking.sol	(date 1673011230395)
@@ -10,18 +10,18 @@
 import "src/interfaces/INodeOperatorsRegistry.sol";
 import "src/interfaces/ILiquidStaking.sol";
 
-contract LiquidStaking is Initializable, UUPSUpgradeable, ReentrancyGuardUpgradeable, OwnableUpgradeable, PausableUpgradeable, ILiquidStaking{
-    
+contract LiquidStaking is Initializable, UUPSUpgradeable, ReentrancyGuardUpgradeable, OwnableUpgradeable, PausableUpgradeable, ILiquidStaking {
+
     bytes private withdrawalCredentials;
-    uint256 private totalBeaconValidators ;
-    bytes32 private nodeRankingCommitment ;
+    uint256 private totalBeaconValidators;
+    bytes32 private nodeRankingCommitment;
     uint256 public constant depositSize = 32 ether;
-    uint256 private depositFeeRate ;
+    uint256 private depositFeeRate;
     uint256 public constant totalBasisPoints = 10000;
     uint256 public constant DEPOSIT_SIZE = 32 ether;
-    uint256 private bufferedEtherPosition ;
-    uint256 private transientEtherPosition ;
-    uint256 private beaconEtherPosition ;
+    uint256 private bufferedEtherPosition;
+    uint256 private transientEtherPosition;
+    uint256 private beaconEtherPosition;
 
     mapping(uint256 => uint256) public operatorPoolBalances;
 
@@ -31,12 +31,12 @@
 
     INodeOperatorsRegistry iNodeOperatorRegistry;
     // function initialize( bytes memory withdrawalCreds, address _validatorNftAddress , address _nETHAddress, address _nodeOperatorRegistry  ) external initializer {
-    function initialize( bytes memory withdrawalCreds, address _nodeOperatorRegistry ) external initializer {
-        __Ownable_init(); 
+    function initialize(bytes memory withdrawalCreds, address _nodeOperatorRegistry) external initializer {
+        __Ownable_init();
         __UUPSUpgradeable_init();
         __ReentrancyGuard_init();
         withdrawalCredentials = withdrawalCreds;
-        iNodeOperatorRegistry = INodeOperatorsRegistry(_nodeOperatorRegistry) ;
+        iNodeOperatorRegistry = INodeOperatorsRegistry(_nodeOperatorRegistry);
         // IVNFT vnft = IVNFT(_validatorNftAddress) ;
         // INETH iNETH = INETH(_nETHAddress) ;
     }
@@ -44,20 +44,20 @@
     function _authorizeUpgrade(address) internal override onlyOwner {}
 
     function stakeETH(address _referral, uint256 _node_operator) external payable nonReentrant {
-        
-        require(iNodeOperatorRegistry.isTrustedOperator(_node_operator) == true , "The message sender is not part of Trusted KingHash Operators");
+
+        require(iNodeOperatorRegistry.isTrustedOperator(_node_operator) == true, "The message sender is not part of Trusted KingHash Operators");
         require(msg.value != 0, "Stake amount must not be Zero");
         require(msg.value >= 100 wei, "Stake amount must be minimum  100 wei");
-        require(_referral != address(0x0), "Referral address must be provided") ;
+        require(_referral != address(0x0), "Referral address must be provided");
 
-        uint256 depositNet ;
-        if(getDepositFeeRate() == 0 ){
+        uint256 depositNet;
+        if (getDepositFeeRate() == 0) {
             depositNet = msg.value;
         }
-        else {         
-            depositNet = getDepositFeeRate() / totalBasisPoints * msg.value ;
+        else {
+            depositNet = getDepositFeeRate() / totalBasisPoints * msg.value;
         }
-        addBufferedEtherPosition(depositNet) ;
+        addBufferedEtherPosition(depositNet);
         addToOperatorBalance(_node_operator, depositNet);
         // iNETH.mint(msg.sender, depositNet);
 
@@ -65,10 +65,10 @@
     }
 
     function mintNFT(bytes calldata data) external payable nonReentrant {
-        require(msg.value >= DEPOSIT_SIZE , "Stake amount must be minimum 32 ether");
+        require(msg.value >= DEPOSIT_SIZE, "Stake amount must be minimum 32 ether");
         // require(iNodeOperatorRegistry.checkOperator(_node_operator) == true , "The message sender is not part of KingHash Operators");
         // eth32Route();
-     }
+    }
 
     //  function unstake()nonReentrant whenNotPaused {}
 
@@ -79,7 +79,7 @@
         addUserGasHeight
         burnKETH
         transferNFT
-    } */ 
+    } */
 
     /*  function unwrapNFT(){
             require(iNodeOperatorRegistry.isTrustedOperator(_node_operator) == true , "The message sender is not part of Trusted KingHash Operators");
@@ -87,57 +87,56 @@
             transferFromNFT from VNFT
             removeUserGasHeight from EexceutionVault
             mintKETH from NETH
-    }*/ 
+    }*/
 
     //  function burnNFT(){}
 
 
-    function handleOracleReport(uint256 data, bytes32 nodeRankingCommitment) external override{
-       
+    function handleOracleReport(uint64 _beaconBalance, uint32 _beaconValidators, bytes32 nodeRankingCommitment) external override {
+
     }
-    
 
 
-    function getTotalPooledEther() external override returns(uint256){
-        return bufferedEtherPosition + transientEtherPosition + beaconEtherPosition ; 
+    function getTotalPooledEther() external override returns (uint256){
+        return bufferedEtherPosition + transientEtherPosition + beaconEtherPosition;
     }
 
-    function getChainUpFromNodeRegistry() internal pure returns(uint256) {
-         return  1 ;
+    function getChainUpFromNodeRegistry() internal pure returns (uint256) {
+        return 1;
     }
 
     function addBufferedEtherPosition(uint256 _amt) internal {
-        bufferedEtherPosition += _amt ;
+        bufferedEtherPosition += _amt;
     }
 
     function subtractBufferedEtherPosition(uint256 _amt) internal {
-        bufferedEtherPosition -= _amt ;
+        bufferedEtherPosition -= _amt;
     }
 
     function addTransientEtherPosition(uint256 _amt) internal {
-        transientEtherPosition += _amt ;
+        transientEtherPosition += _amt;
     }
 
     function subtractTransientEtherPosition(uint256 _amt) internal {
-        transientEtherPosition -= _amt ;
+        transientEtherPosition -= _amt;
     }
 
     function addBeaconEtherPosition(uint256 _amt) internal {
-        beaconEtherPosition += _amt ;
+        beaconEtherPosition += _amt;
     }
 
     function subtractBeaconEtherPosition(uint256 _amt) internal {
-        beaconEtherPosition -= _amt ;
+        beaconEtherPosition -= _amt;
     }
 
     function setDepositFeeRate(uint256 _rate) external onlyOwner {
-        depositFeeRate = _rate ;
+        depositFeeRate = _rate;
     }
 
-    function getDepositFeeRate() internal view returns(uint256) {
-        return depositFeeRate ;
+    function getDepositFeeRate() internal view returns (uint256) {
+        return depositFeeRate;
     }
-    
+
     function addToOperatorBalance(uint256 operator, uint256 amount) internal {
         // require(iNodeOperatorRegistry.checkTrustOperator(_node_operator) == true , "The message sender is not part of KingHash Operators");
         operatorPoolBalances[operator] += amount;
Index: src/interfaces/ILiquidStaking.sol
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.7;\n\ninterface ILiquidStaking {\n\n    function handleOracleReport(uint256  _data, bytes32 nodeRankingCommitment) external;\n\n    function getTotalPooledEther() external returns(uint256);\n\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/interfaces/ILiquidStaking.sol b/src/interfaces/ILiquidStaking.sol
--- a/src/interfaces/ILiquidStaking.sol	(revision 2ae63f478b83c9be780b7f24cbdce90b62da1919)
+++ b/src/interfaces/ILiquidStaking.sol	(date 1673011198381)
@@ -3,9 +3,9 @@
 
 interface ILiquidStaking {
 
-    function handleOracleReport(uint256  _data, bytes32 nodeRankingCommitment) external;
+    function handleOracleReport(uint64 _beaconBalance, uint32 _beaconValidators, bytes32 nodeRankingCommitment) external;
 
-    function getTotalPooledEther() external returns(uint256);
+    function getTotalPooledEther() external returns (uint256);
 
 
-}
\ No newline at end of file
+}
Index: src/oracles/BeaconOracle.sol
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.7;\n\nimport \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"src/interfaces/IBeaconOracle.sol\";\nimport \"src/interfaces/ILiquidStaking.sol\";\nimport \"src/interfaces/INodeOperatorsRegistry.sol\";\n\n/**\n  * @title Beacon Oracle and Dao\n  *\n  * BeaconOracle data acquisition and verification\n  * Dao management\n  */\ncontract BeaconOracle is Initializable, ReentrancyGuardUpgradeable, OwnableUpgradeable, UUPSUpgradeable, IBeaconOracle {\n\n    // Dao member list\n    address[] public daoMembers;\n\n    // The epoch of each frame (currently 24h for 225)\n    uint64 internal constant EPOCHS_PER_FRAME = 225;\n\n    // Number of slots corresponding to each epoch\n    uint64 internal constant SLOTS_PER_EPOCH = 32;\n\n    // Base time (default beacon creation time)\n    uint64 internal constant GENESIS_TIME = 1606824023;\n\n    // Seconds for each slot\n    uint64 internal constant SECONDS_PER_SLOT = 12;\n\n    // The expected epoch Id is required by oracle for report Beacon\n    uint256 public expectedEpochId;\n\n    // k: hash of the uploaded result v: The number of times the same result has been uploaded\n    mapping(bytes32 => uint256) internal submittedReports;\n\n    // k:operator address v: Whether to send\n    mapping(address => bool) internal hasSubmitted;\n\n    // Whether the current frame has reached Quorum\n    bool public isToQuorum;\n\n    // current reportBeacon beaconBalances\n    uint256 public beaconBalances;\n\n    // current reportBeacon beaconValidators\n    uint32 public beaconActiveValidators;\n\n    address public liquidStakingContract;\n\n    address public nodeOperatorsContract;\n\n    function initalizeOracle(address _liquidStaking, address _nodeOperatorsContract, address[] memory _daoMembers) public initializer {\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n\n        liquidStakingContract = _liquidStaking;\n        nodeOperatorsContract = _nodeOperatorsContract;\n        daoMembers = _daoMembers;\n        // So the initial is the first epochId\n        expectedEpochId = _getFirstEpochOfDay(_getCurrentEpochId()) + EPOCHS_PER_FRAME;\n    }\n\n    modifier onlyDaoMember {\n        require(daoMembers.length > 0, \"DaoMembers is empty\");\n        //        require(daoMembers.indexOf(msg.sender) >= 0, \"Sender is not a Dao's member\");\n        _;\n    }\n\n    function addDaoMember(address _daoMember) external onlyDaoMember {\n        daoMembers.push(_daoMember);\n    }\n\n    function removeDaoMember(address _daoMember) external onlyDaoMember {\n        //        uint index = daoMembers.indexOf(_daoMember);\n        //        daoMembers.remove(index);\n    }\n\n    function isDaoMember(address _daoMember) external view returns (bool) {\n        return _isDaoMember(_daoMember);\n    }\n\n    function _isDaoMember(address _daoMember) internal view returns (bool) {\n        //        return daoMembers.indexOf(_daoMember) >= 0;\n        return false;\n    }\n\n    function getQuorum() public view returns (uint256) {\n        uint256 n = getNodeOperatorsContract().getNodeOperatorsCount() * 2 / 3;\n        return 1 + n;\n    }\n\n    // todo 权限问题：dao成员、报名单operator、合约所有者\n    function resetExpectedEpochId() external onlyOwner {\n        expectedEpochId = _getFirstEpochOfDay(_getCurrentEpochId()) + EPOCHS_PER_FRAME;\n    }\n\n    function getLiquidStaking() public view returns (ILiquidStaking) {\n        return ILiquidStaking(liquidStakingContract);\n    }\n\n    function getNodeOperatorsContract() public view returns (INodeOperatorsRegistry) {\n        return INodeOperatorsRegistry(nodeOperatorsContract);\n    }\n\n    // todo 可以添加一些 emit 供oracle进行订阅\n    function reportBeacon(uint256 epochId, uint256 data, bytes32 nodeRankingCommitment) external {\n        require(isToQuorum, \"Quorum has been reached.\");\n        require(_isDaoMember(msg.sender), \"Not part of DAOs' trusted list of addresses\");\n        require(epochId == expectedEpochId, \"The epoch submitted is not expected.\");\n        require(hasSubmitted[msg.sender] == false, \"This msg.sender has already submitted the vote.\");\n\n        bytes32 hash = keccak256(abi.encode(data, nodeRankingCommitment));\n        submittedReports[hash]++;\n        hasSubmitted[msg.sender] = true;\n\n        uint256 quorum = getQuorum();\n        if (submittedReports[hash] > quorum) {\n            pushReport(data, nodeRankingCommitment);\n        }\n    }\n\n    function pushReport(uint256 data, bytes32 nodeRankingCommitment) internal {\n        ILiquidStaking liquidStaking = getLiquidStaking();\n        liquidStaking.handleOracleReport(data, nodeRankingCommitment);\n        uint256 nextExpectedEpoch = expectedEpochId + EPOCHS_PER_FRAME;\n        expectedEpochId = nextExpectedEpoch;\n        // The report passed on the same day\n        isToQuorum = true;\n\n        // todo\n        // Clear the map data that stores the report results\n        //        delete submittedReports;\n        //        delete hasSubmitted;\n    }\n\n    // todo\n    function verifyNftValue(bytes memory pubkey, uint256 validatorBalance, uint256 nftTokenID) external view returns (bool){\n\n        return false;\n    }\n\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n    function _getFirstEpochOfDay(uint256 _epochId) internal pure returns (uint256) {\n        return (_epochId / EPOCHS_PER_FRAME) * EPOCHS_PER_FRAME;\n    }\n\n    function _getCurrentEpochId() internal view returns (uint256) {\n        // The number of epochs after the base time\n        return (_getTime() - GENESIS_TIME) / (SLOTS_PER_EPOCH * SECONDS_PER_SLOT);\n    }\n\n    function _getTime() internal view returns (uint256) {\n        return block.timestamp;\n    }\n\n    function reportEncode(uint256 beaconBalances, uint32 beaconActiveValidators) internal returns (uint256) {\n        return (beaconBalances << 64) | beaconActiveValidators;\n    }\n\n    function reportDecode(uint256 input) internal {\n        beaconBalances = input >> 64;\n        // todo\n        //        beaconActiveValidators = input & 0xffffffff;\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/oracles/BeaconOracle.sol b/src/oracles/BeaconOracle.sol
--- a/src/oracles/BeaconOracle.sol	(revision 2ae63f478b83c9be780b7f24cbdce90b62da1919)
+++ b/src/oracles/BeaconOracle.sol	(date 1673011271715)
@@ -4,6 +4,7 @@
 import "openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
 import "openzeppelin-contracts-upgradeable/access/OwnableUpgradeable.sol";
 import "openzeppelin-contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
+import "openzeppelin-contracts/utils/cryptography/MerkleProof.sol";
 import "src/interfaces/IBeaconOracle.sol";
 import "src/interfaces/ILiquidStaking.sol";
 import "src/interfaces/INodeOperatorsRegistry.sol";
@@ -14,13 +15,20 @@
   * BeaconOracle data acquisition and verification
   * Dao management
   */
-contract BeaconOracle is Initializable, ReentrancyGuardUpgradeable, OwnableUpgradeable, UUPSUpgradeable, IBeaconOracle {
+contract BeaconOracle is
+Initializable,
+ReentrancyGuardUpgradeable,
+OwnableUpgradeable,
+UUPSUpgradeable,
+IBeaconOracle
+{
+    using MerkleProof for uint256;
 
-    // Dao member list
-    address[] public daoMembers;
+    // dao address
+    address public dao;
 
-    // The epoch of each frame (currently 24h for 225)
-    uint64 internal constant EPOCHS_PER_FRAME = 225;
+    // oracle committee members
+    mapping(address => bool) internal reporters;
 
     // Number of slots corresponding to each epoch
     uint64 internal constant SLOTS_PER_EPOCH = 32;
@@ -31,62 +39,83 @@
     // Seconds for each slot
     uint64 internal constant SECONDS_PER_SLOT = 12;
 
+    // The epoch of each frame (currently 24h for 225)
+    uint32 public epochsPerFrame;
+
     // The expected epoch Id is required by oracle for report Beacon
     uint256 public expectedEpochId;
 
-    // k: hash of the uploaded result v: The number of times the same result has been uploaded
-    mapping(bytes32 => uint256) internal submittedReports;
+    // map(k:epochId v(k:Upload the resulting hash v:The number of times you get the same result))
+    mapping(uint256 => mapping(bytes32 => uint256)) internal submittedReports;
 
-    // k:operator address v: Whether to send
-    mapping(address => bool) internal hasSubmitted;
+    // map(k:epochId v(k:reporters address v:is reportBeacon))
+    mapping(uint256 => mapping(address => bool)) internal hasSubmitted;
+
+    // reporting storage
+    uint256[] private currentReportVariants;
 
     // Whether the current frame has reached Quorum
-    bool public isToQuorum;
+    bool public isQuorum;
 
     // current reportBeacon beaconBalances
     uint256 public beaconBalances;
 
     // current reportBeacon beaconValidators
-    uint32 public beaconActiveValidators;
+    uint64 public beaconActiveValidators;
+
+    // reportBeacon merkleTreeRoot storage
+    bytes32 private merkleTreeRoot;
 
     address public liquidStakingContract;
 
     address public nodeOperatorsContract;
 
-    function initalizeOracle(address _liquidStaking, address _nodeOperatorsContract, address[] memory _daoMembers) public initializer {
+    function initalizeOracle(address _liquidStaking, address _nodeOperatorsContract, address[] memory _reporters) public initializer {
         __Ownable_init();
         __UUPSUpgradeable_init();
         __ReentrancyGuard_init();
 
         liquidStakingContract = _liquidStaking;
         nodeOperatorsContract = _nodeOperatorsContract;
-        daoMembers = _daoMembers;
+        _initReporters(_reporters);
+        epochsPerFrame = 225;
         // So the initial is the first epochId
-        expectedEpochId = _getFirstEpochOfDay(_getCurrentEpochId()) + EPOCHS_PER_FRAME;
+        expectedEpochId = _getFirstEpochOfDay(_getCurrentEpochId()) + epochsPerFrame;
     }
 
-    modifier onlyDaoMember {
-        require(daoMembers.length > 0, "DaoMembers is empty");
-        //        require(daoMembers.indexOf(msg.sender) >= 0, "Sender is not a Dao's member");
+    modifier onlyDao() {
+        require(msg.sender == dao, "AUTH_FAILED");
         _;
     }
 
-    function addDaoMember(address _daoMember) external onlyDaoMember {
-        daoMembers.push(_daoMember);
+    function _initReporters(address[] memory _reporters) internal {
+        for (uint i = 0; i < _reporters.length; i++) {
+            reporters[_reporters[i]] = true;
+        }
+    }
+
+    function addReporter(address _reporter) external onlyDao {
+        reporters[_reporter] = true;
     }
 
-    function removeDaoMember(address _daoMember) external onlyDaoMember {
-        //        uint index = daoMembers.indexOf(_daoMember);
-        //        daoMembers.remove(index);
+    function removeReporter(address _reporter) external onlyDao {
+        delete reporters[_reporter];
     }
 
-    function isDaoMember(address _daoMember) external view returns (bool) {
-        return _isDaoMember(_daoMember);
+    function isReporter(address _reporter) external view returns (bool) {
+        return _isReporter(_reporter);
     }
 
-    function _isDaoMember(address _daoMember) internal view returns (bool) {
-        //        return daoMembers.indexOf(_daoMember) >= 0;
-        return false;
+    function _isReporter(address _reporter) internal view returns (bool) {
+        return reporters[_reporter];
+    }
+
+    function resetExpectedEpochId() external onlyDao {
+        expectedEpochId = _getFirstEpochOfDay(_getCurrentEpochId()) + epochsPerFrame;
+    }
+
+    function resetEpochsPerFrame(uint32 _epochsPerFrame) external onlyDao {
+        epochsPerFrame = _epochsPerFrame;
     }
 
     function getQuorum() public view returns (uint256) {
@@ -94,11 +123,6 @@
         return 1 + n;
     }
 
-    // todo 权限问题：dao成员、报名单operator、合约所有者
-    function resetExpectedEpochId() external onlyOwner {
-        expectedEpochId = _getFirstEpochOfDay(_getCurrentEpochId()) + EPOCHS_PER_FRAME;
-    }
-
     function getLiquidStaking() public view returns (ILiquidStaking) {
         return ILiquidStaking(liquidStakingContract);
     }
@@ -107,47 +131,49 @@
         return INodeOperatorsRegistry(nodeOperatorsContract);
     }
 
-    // todo 可以添加一些 emit 供oracle进行订阅
-    function reportBeacon(uint256 epochId, uint256 data, bytes32 nodeRankingCommitment) external {
-        require(isToQuorum, "Quorum has been reached.");
-        require(_isDaoMember(msg.sender), "Not part of DAOs' trusted list of addresses");
-        require(epochId == expectedEpochId, "The epoch submitted is not expected.");
-        require(hasSubmitted[msg.sender] == false, "This msg.sender has already submitted the vote.");
+    function reportBeacon(uint256 _epochId, uint64 _beaconBalance, uint32 _beaconValidators, bytes32 _nodeRankingCommitment) external {
+        require(isQuorum, "Quorum has been reached.");
+        require(_isReporter(msg.sender), "Not part of DAOs' trusted list of addresses");
+        require(_epochId == expectedEpochId, "The epoch submitted is not expected.");
+        require(hasSubmitted[_epochId][msg.sender], "This msg.sender has already submitted the vote.");
 
-        bytes32 hash = keccak256(abi.encode(data, nodeRankingCommitment));
-        submittedReports[hash]++;
-        hasSubmitted[msg.sender] = true;
+        bytes32 hash = keccak256(abi.encode(_beaconBalance, _beaconValidators, _nodeRankingCommitment));
+        submittedReports[_epochId][hash]++;
+        hasSubmitted[_epochId][msg.sender] = true;
 
         uint256 quorum = getQuorum();
-        if (submittedReports[hash] > quorum) {
-            pushReport(data, nodeRankingCommitment);
+        if (submittedReports[_epochId][hash] > quorum) {
+            _pushReport(_beaconBalance, _beaconValidators, _nodeRankingCommitment);
         }
     }
+
+    function isReportBeacon(uint256 _epochId) external view returns (bool) {
+        return hasSubmitted[_epochId][msg.sender] == true;
+    }
 
-    function pushReport(uint256 data, bytes32 nodeRankingCommitment) internal {
+    function _pushReport(uint64 _beaconBalance, uint32 _beaconValidators, bytes32 _nodeRankingCommitment) internal {
         ILiquidStaking liquidStaking = getLiquidStaking();
-        liquidStaking.handleOracleReport(data, nodeRankingCommitment);
-        uint256 nextExpectedEpoch = expectedEpochId + EPOCHS_PER_FRAME;
+        liquidStaking.handleOracleReport(_beaconBalance, _beaconValidators, _nodeRankingCommitment);
+        uint256 nextExpectedEpoch = expectedEpochId + epochsPerFrame;
+
         expectedEpochId = nextExpectedEpoch;
         // The report passed on the same day
-        isToQuorum = true;
+        isQuorum = true;
 
-        // todo
-        // Clear the map data that stores the report results
-        //        delete submittedReports;
-        //        delete hasSubmitted;
+        // todo no delete
+        //        delete submittedReports[_epochId];
+        //        delete hasSubmitted[_epochId];
     }
 
-    // todo
-    function verifyNftValue(bytes memory pubkey, uint256 validatorBalance, uint256 nftTokenID) external view returns (bool){
-
-        return false;
+    // byte32 memory pubkey, uint64 validatorBalance, uint256 nftTokenID
+    function verifyNftValue(bytes32[] memory proof, bytes32 leaf) external view returns (bool){
+        return MerkleProof.verify(proof, merkleTreeRoot, leaf);
     }
 
     function _authorizeUpgrade(address) internal override onlyOwner {}
 
-    function _getFirstEpochOfDay(uint256 _epochId) internal pure returns (uint256) {
-        return (_epochId / EPOCHS_PER_FRAME) * EPOCHS_PER_FRAME;
+    function _getFirstEpochOfDay(uint256 _epochId) internal view returns (uint256) {
+        return (_epochId / epochsPerFrame) * epochsPerFrame;
     }
 
     function _getCurrentEpochId() internal view returns (uint256) {
@@ -159,14 +185,4 @@
         return block.timestamp;
     }
 
-    function reportEncode(uint256 beaconBalances, uint32 beaconActiveValidators) internal returns (uint256) {
-        return (beaconBalances << 64) | beaconActiveValidators;
-    }
-
-    function reportDecode(uint256 input) internal {
-        beaconBalances = input >> 64;
-        // todo
-        //        beaconActiveValidators = input & 0xffffffff;
-    }
-
 }
Index: test/BeaconOracleTest.sol
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/test/BeaconOracleTest.sol b/test/BeaconOracleTest.sol
new file mode 100644
--- /dev/null	(date 1673008163027)
+++ b/test/BeaconOracleTest.sol	(date 1673008163027)
@@ -0,0 +1,15 @@
+// SPDX-License-Identifier: UNLICENSED
+pragma solidity ^0.8.7;
+
+import "forge-std/Test.sol";
+import "src/oracles/BeaconOracle.sol";
+
+contract BeaconOracleTest is Test {
+
+    BeaconOracle beaconOracle;
+
+    //    function initializer() private {
+    //        beaconOracle.initialize();
+    //    }
+
+}
