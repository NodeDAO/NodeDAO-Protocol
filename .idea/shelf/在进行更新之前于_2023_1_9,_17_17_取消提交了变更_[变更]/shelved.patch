Index: .gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Compiler files\ncache/\nout/\n\n# Ignores development broadcast logs\n!/broadcast\n/broadcast/*/31337/\n/broadcast/**/dry-run/\n\n# Dotenv file\n.env\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.gitignore b/.gitignore
--- a/.gitignore	(revision 69610968f88261a9813573e0efaefd99875a55cd)
+++ b/.gitignore	(date 1673254034491)
@@ -9,3 +9,5 @@
 
 # Dotenv file
 .env
+.history/
+.vscode/
Index: src/LiquidStaking.sol
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.7;\n\nimport \"openzeppelin-contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"openzeppelin-contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport \"src/interfaces/INodeOperatorsRegistry.sol\";\nimport \"src/interfaces/ILiquidStaking.sol\";\nimport \"src/interfaces/INEth.sol\";\n\ncontract LiquidStaking is Initializable, UUPSUpgradeable, ReentrancyGuardUpgradeable, OwnableUpgradeable, PausableUpgradeable, ILiquidStaking{\n\n    bytes private withdrawalCredentials;\n    uint256 private totalBeaconValidators ;\n    bytes32 private nodeRankingCommitment ;\n    uint256 public constant depositSize = 32 ether;\n    uint256 private depositFeeRate ;\n    uint256 public constant totalBasisPoints = 10000;\n    uint256 public constant DEPOSIT_SIZE = 32 ether;\n    uint256 private bufferedEtherPosition ;\n    uint256 private transientEtherPosition ;\n    uint256 private beaconEtherPosition ;\n\n    mapping(uint256 => uint256) public operatorPoolBalances;\n\n    event DepositReceived(address indexed from, uint256 amount, address indexed _referral);\n    event ELRewardsReceived(uint256 balance);\n    event EtherDeposited(address from, uint256 balance, uint256 height);\n\n    INodeOperatorsRegistry iNodeOperatorRegistry;\n    INEth iNETH;\n    // function initialize( bytes memory withdrawalCreds, address _validatorNftAddress , address _nETHAddress, address _nodeOperatorRegistry  ) external initializer {\n    function initialize( bytes memory withdrawalCreds, address _nodeOperatorRegistry, address _nETHAddress ) external initializer {\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        withdrawalCredentials = withdrawalCreds;\n        iNodeOperatorRegistry = INodeOperatorsRegistry(_nodeOperatorRegistry) ;\n        // IVNFT vnft = IVNFT(_validatorNftAddress) ;\n         iNETH = INEth(_nETHAddress) ;\n    }\n\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n    function stakeETH(address _referral, uint256 _node_operator) external payable nonReentrant {\n        require(msg.value != 0, \"Stake amount must not be Zero\");\n        require(iNodeOperatorRegistry.isTrustedOperator(_node_operator) == true , \"The message sender is not part of Trusted KingHash Operators\");\n        require(msg.value >= 100 wei, \"Stake amount must be minimum  100 wei\");\n        require(_referral != address(0x0), \"Referral address must be provided\") ;\n\n        uint256 depositNet;\n        if(getDepositFeeRate() == 0) {\n            depositNet = msg.value;\n        }\n        else {\n            depositNet = msg.value - (getDepositFeeRate() / totalBasisPoints * msg.value);\n        }\n        addBufferedEtherPosition(depositNet) ;\n        addToOperatorBalance(_node_operator, depositNet);\n        iNETH.mint(depositNet, msg.sender);\n\n        emit DepositReceived(msg.sender, msg.value, _referral);\n    }\n\n\n    //    function eth32Route(bytes calldata data) internal returns (bool) {\n    //     bytes32 hash = precheck(data);\n    //     signercheck(bytes32(data[256:288]), bytes32(data[288:320]), uint8(bytes1(data[1])), hash, vault.authority());\n    //     deposit(data);\n    //     vault.settle(); // we can optimize this to settle only a particular vault\n    //     //nftContract.whiteListMint(data[16:64], msg.sender);\n    //     return true;\n    // }\n\n\n    //  function unstake()nonReentrant whenNotPaused {}\n\n    /*  function wrapNFT(){\n        checkWrapNftIsValid  from VNFT\n        checkTransferredkETH from ERC20\n        verifyNFTValue  from VNFT\n        addUserGasHeight from EexceutionVault\n        burnNETH  from NETH\n        transferNFT\n    } */\n\n    /*  function unwrapNFT(){\n            require(iNodeOperatorRegistry.isTrustedOperator(_node_operator) == true , \"The message sender is not part of Trusted KingHash Operators\");\n            verifyNFTValue from Oracle\n            transferFromNFT from VNFT\n            removeUserGasHeight from EexceutionVault\n            mintNETH from NETH\n    }*/\n\n    /*   function unstakeNFT(){\n        // require(iNodeOperatorRegistry.getNodeOperator(_node_operator) == true , \"The message sender is not part of KingHash Operators\");\n        // check caller nft , trasnfer this nft to protocoo ,check nodeOperatorRanking, take down validator\n    }*/\n\n\n    function handleOracleReport(uint64 _beaconBalance, uint32 _beaconValidators, bytes32 nodeRankingCommitment) external override {\n        //    require(msg.sender == getOracle(), \"APP_AUTH_FAILED\");\n        // (uint256 _beaconBalance, uint256 _beaconValidators) = decode(data);\n        // uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        // require(_beaconValidators <= depositedValidators, \"REPORTED_MORE_DEPOSITED\");\n        // uint256 beaconValidators = BEACON_VALIDATORS_POSITION.getStorageUint256();\n        // require(_beaconValidators >= beaconValidators, \"REPORTED_LESS_VALIDATORS\");\n        // uint256 appearedValidators = _beaconValidators.sub(beaconValidators);\n    }\n\n\n\n    function getTotalPooledEther() external override returns(uint256){\n        return bufferedEtherPosition + transientEtherPosition + beaconEtherPosition ;\n    }\n\n    function getChainUpFromNodeRegistry() internal pure returns(uint256) {\n         return  1 ;\n    }\n\n    function addBufferedEtherPosition(uint256 _amt) internal {\n        bufferedEtherPosition += _amt ;\n    }\n\n    function subtractBufferedEtherPosition(uint256 _amt) internal {\n        bufferedEtherPosition -= _amt ;\n    }\n\n    function addTransientEtherPosition(uint256 _amt) internal {\n        transientEtherPosition += _amt ;\n    }\n\n    function subtractTransientEtherPosition(uint256 _amt) internal {\n        transientEtherPosition -= _amt ;\n    }\n\n    function addBeaconEtherPosition(uint256 _amt) internal {\n        beaconEtherPosition += _amt ;\n    }\n\n    function subtractBeaconEtherPosition(uint256 _amt) internal {\n        beaconEtherPosition -= _amt ;\n    }\n\n    function setDepositFeeRate(uint256 _rate) external onlyOwner {\n        depositFeeRate = _rate ;\n    }\n\n    function getDepositFeeRate() internal view returns(uint256) {\n        return depositFeeRate ;\n    }\n\n    function addToOperatorBalance(uint256 operator, uint256 amount) internal {\n        // require(iNodeOperatorRegistry.checkTrustOperator(_node_operator) == true , \"The message sender is not part of KingHash Operators\");\n        operatorPoolBalances[operator] += amount;\n    }\n\n    function computeWithdrawableEther() external view returns(uint256){\n    //  consider EL rewards, Buffered/Deposited Ether\n    return bufferedEtherPosition +  computeELRewards() ;\n    }\n\n    function computeELRewards() internal pure returns (uint256) {\n          return 0;\n    }\n\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/LiquidStaking.sol b/src/LiquidStaking.sol
--- a/src/LiquidStaking.sol	(revision 69610968f88261a9813573e0efaefd99875a55cd)
+++ b/src/LiquidStaking.sol	(date 1673255778904)
@@ -11,18 +11,18 @@
 import "src/interfaces/ILiquidStaking.sol";
 import "src/interfaces/INEth.sol";
 
-contract LiquidStaking is Initializable, UUPSUpgradeable, ReentrancyGuardUpgradeable, OwnableUpgradeable, PausableUpgradeable, ILiquidStaking{
+contract LiquidStaking is Initializable, UUPSUpgradeable, ReentrancyGuardUpgradeable, OwnableUpgradeable, PausableUpgradeable, ILiquidStaking {
 
     bytes private withdrawalCredentials;
-    uint256 private totalBeaconValidators ;
-    bytes32 private nodeRankingCommitment ;
+    uint256 private totalBeaconValidators;
+    bytes32 private nodeRankingCommitment;
     uint256 public constant depositSize = 32 ether;
-    uint256 private depositFeeRate ;
+    uint256 private depositFeeRate;
     uint256 public constant totalBasisPoints = 10000;
     uint256 public constant DEPOSIT_SIZE = 32 ether;
-    uint256 private bufferedEtherPosition ;
-    uint256 private transientEtherPosition ;
-    uint256 private beaconEtherPosition ;
+    uint256 private bufferedEtherPosition;
+    uint256 private transientEtherPosition;
+    uint256 private beaconEtherPosition;
 
     mapping(uint256 => uint256) public operatorPoolBalances;
 
@@ -33,32 +33,32 @@
     INodeOperatorsRegistry iNodeOperatorRegistry;
     INEth iNETH;
     // function initialize( bytes memory withdrawalCreds, address _validatorNftAddress , address _nETHAddress, address _nodeOperatorRegistry  ) external initializer {
-    function initialize( bytes memory withdrawalCreds, address _nodeOperatorRegistry, address _nETHAddress ) external initializer {
+    function initialize(bytes memory withdrawalCreds, address _nodeOperatorRegistry, address _nETHAddress) external initializer {
         __Ownable_init();
         __UUPSUpgradeable_init();
         __ReentrancyGuard_init();
         withdrawalCredentials = withdrawalCreds;
-        iNodeOperatorRegistry = INodeOperatorsRegistry(_nodeOperatorRegistry) ;
+        iNodeOperatorRegistry = INodeOperatorsRegistry(_nodeOperatorRegistry);
         // IVNFT vnft = IVNFT(_validatorNftAddress) ;
-         iNETH = INEth(_nETHAddress) ;
+        iNETH = INEth(_nETHAddress);
     }
 
     function _authorizeUpgrade(address) internal override onlyOwner {}
 
     function stakeETH(address _referral, uint256 _node_operator) external payable nonReentrant {
         require(msg.value != 0, "Stake amount must not be Zero");
-        require(iNodeOperatorRegistry.isTrustedOperator(_node_operator) == true , "The message sender is not part of Trusted KingHash Operators");
+        require(iNodeOperatorRegistry.isTrustedOperator(_node_operator) == true, "The message sender is not part of Trusted KingHash Operators");
         require(msg.value >= 100 wei, "Stake amount must be minimum  100 wei");
-        require(_referral != address(0x0), "Referral address must be provided") ;
+        require(_referral != address(0x0), "Referral address must be provided");
 
         uint256 depositNet;
-        if(getDepositFeeRate() == 0) {
+        if (getDepositFeeRate() == 0) {
             depositNet = msg.value;
         }
         else {
             depositNet = msg.value - (getDepositFeeRate() / totalBasisPoints * msg.value);
         }
-        addBufferedEtherPosition(depositNet) ;
+        addBufferedEtherPosition(depositNet);
         addToOperatorBalance(_node_operator, depositNet);
         iNETH.mint(depositNet, msg.sender);
 
@@ -101,7 +101,7 @@
     }*/
 
 
-    function handleOracleReport(uint64 _beaconBalance, uint32 _beaconValidators, bytes32 nodeRankingCommitment) external override {
+    function handleOracleReport(uint64 _beaconBalance, uint32 _beaconValidators) external override {
         //    require(msg.sender == getOracle(), "APP_AUTH_FAILED");
         // (uint256 _beaconBalance, uint256 _beaconValidators) = decode(data);
         // uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();
@@ -112,45 +112,44 @@
     }
 
 
-
-    function getTotalPooledEther() external override returns(uint256){
-        return bufferedEtherPosition + transientEtherPosition + beaconEtherPosition ;
+    function getTotalPooledEther() external override returns (uint256){
+        return bufferedEtherPosition + transientEtherPosition + beaconEtherPosition;
     }
 
-    function getChainUpFromNodeRegistry() internal pure returns(uint256) {
-         return  1 ;
+    function getChainUpFromNodeRegistry() internal pure returns (uint256) {
+        return 1;
     }
 
     function addBufferedEtherPosition(uint256 _amt) internal {
-        bufferedEtherPosition += _amt ;
+        bufferedEtherPosition += _amt;
     }
 
     function subtractBufferedEtherPosition(uint256 _amt) internal {
-        bufferedEtherPosition -= _amt ;
+        bufferedEtherPosition -= _amt;
     }
 
     function addTransientEtherPosition(uint256 _amt) internal {
-        transientEtherPosition += _amt ;
+        transientEtherPosition += _amt;
     }
 
     function subtractTransientEtherPosition(uint256 _amt) internal {
-        transientEtherPosition -= _amt ;
+        transientEtherPosition -= _amt;
     }
 
     function addBeaconEtherPosition(uint256 _amt) internal {
-        beaconEtherPosition += _amt ;
+        beaconEtherPosition += _amt;
     }
 
     function subtractBeaconEtherPosition(uint256 _amt) internal {
-        beaconEtherPosition -= _amt ;
+        beaconEtherPosition -= _amt;
     }
 
     function setDepositFeeRate(uint256 _rate) external onlyOwner {
-        depositFeeRate = _rate ;
+        depositFeeRate = _rate;
     }
 
-    function getDepositFeeRate() internal view returns(uint256) {
-        return depositFeeRate ;
+    function getDepositFeeRate() internal view returns (uint256) {
+        return depositFeeRate;
     }
 
     function addToOperatorBalance(uint256 operator, uint256 amount) internal {
@@ -158,13 +157,13 @@
         operatorPoolBalances[operator] += amount;
     }
 
-    function computeWithdrawableEther() external view returns(uint256){
-    //  consider EL rewards, Buffered/Deposited Ether
-    return bufferedEtherPosition +  computeELRewards() ;
+    function computeWithdrawableEther() external view returns (uint256){
+        //  consider EL rewards, Buffered/Deposited Ether
+        return bufferedEtherPosition + computeELRewards();
     }
 
     function computeELRewards() internal pure returns (uint256) {
-          return 0;
+        return 0;
     }
 
 
Index: src/interfaces/ILiquidStaking.sol
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.7;\n\ninterface ILiquidStaking {\n\n    function handleOracleReport(uint64 _beaconBalance, uint32 _beaconValidators, bytes32 nodeRankingCommitment) external;\n\n    function getTotalPooledEther() external returns (uint256);\n\n    function computeWithdrawableEther() external view returns(uint256) ;\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/interfaces/ILiquidStaking.sol b/src/interfaces/ILiquidStaking.sol
--- a/src/interfaces/ILiquidStaking.sol	(revision 69610968f88261a9813573e0efaefd99875a55cd)
+++ b/src/interfaces/ILiquidStaking.sol	(date 1673255778896)
@@ -3,10 +3,10 @@
 
 interface ILiquidStaking {
 
-    function handleOracleReport(uint64 _beaconBalance, uint32 _beaconValidators, bytes32 nodeRankingCommitment) external;
+    function handleOracleReport(uint64 _beaconBalance, uint32 _beaconValidators) external;
 
     function getTotalPooledEther() external returns (uint256);
 
-    function computeWithdrawableEther() external view returns(uint256) ;
+    function computeWithdrawableEther() external view returns (uint256);
 
 }
Index: src/oracles/BeaconOracle.sol
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.7;\n\nimport \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"openzeppelin-contracts/utils/cryptography/MerkleProof.sol\";\nimport \"openzeppelin-contracts/utils/structs/EnumerableMap.sol\";\nimport \"src/interfaces/IBeaconOracle.sol\";\nimport \"src/interfaces/ILiquidStaking.sol\";\nimport \"src/interfaces/INodeOperatorsRegistry.sol\";\n\n/**\n  * @title Beacon Oracle and Dao\n  *\n  * BeaconOracle data acquisition and verification\n  * Dao management\n  */\ncontract BeaconOracle is\nInitializable,\nReentrancyGuardUpgradeable,\nOwnableUpgradeable,\nUUPSUpgradeable,\nIBeaconOracle\n{\n    using EnumerableMap for EnumerableMap.Bytes32ToUintMap;\n    using EnumerableMap for EnumerableMap.AddressToUintMap;\n\n    // dao address\n    address public dao;\n\n    // oracle committee members\n    mapping(address => bool) internal oracleMembers;\n\n    uint32 public oracleMemberCount;\n\n    // Number of slots corresponding to each epoch\n    uint64 internal constant SLOTS_PER_EPOCH = 32;\n\n    // Base time (default beacon creation time)\n    uint64 public constant GENESIS_TIME = 1606824023;\n\n    // Seconds for each slot\n    uint64 internal constant SECONDS_PER_SLOT = 12;\n\n    // The epoch of each frame (currently 24h for 225)\n    uint32 public epochsPerFrame;\n\n    // The expected epoch Id is required by oracle for report Beacon\n    uint256 public expectedEpochId;\n\n    // map(k:Upload the resulting hash v:The number of times you get the same result)\n    EnumerableMap.Bytes32ToUintMap internal submittedReports;\n\n    // map(k:oracleMember address v:is reportBeacon)\n    EnumerableMap.AddressToUintMap internal hasSubmitted;\n\n    // Whether the current frame has reached Quorum\n    bool public isQuorum;\n\n    // current reportBeacon beaconBalances\n    uint256 public beaconBalances;\n\n    // current reportBeacon beaconValidators\n    uint64 public beaconActiveValidators;\n\n    // reportBeacon merkleTreeRoot storage\n    bytes32 private merkleTreeRoot;\n\n    address public liquidStakingContract;\n\n    address public nodeOperatorsContract;\n\n    function initialize(address _dao, address _liquidStaking, address _nodeOperatorsContract) public initializer {\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n\n        dao = _dao;\n        liquidStakingContract = _liquidStaking;\n        nodeOperatorsContract = _nodeOperatorsContract;\n        epochsPerFrame = 225;\n        // So the initial is the first epochId\n        expectedEpochId = _getFirstEpochOfDay(_getCurrentEpochId()) + epochsPerFrame;\n    }\n\n    modifier onlyDao() {\n        require(msg.sender == dao, \"AUTH_FAILED\");\n        _;\n    }\n\n    function addOracleMember(address _oracleMember) external onlyDao {\n        oracleMembers[_oracleMember] = true;\n        oracleMemberCount ++;\n\n        emit AddOracleMember(_oracleMember);\n    }\n\n    function removeOracleMember(address _oracleMember) external onlyDao {\n        delete oracleMembers[_oracleMember];\n        oracleMemberCount --;\n\n        emit RemoveOracleMember(_oracleMember);\n    }\n\n    function isOracleMember(address _oracleMember) external view returns (bool) {\n        return _isOracleMember(_oracleMember);\n    }\n\n    function _isOracleMember(address _oracleMember) internal view returns (bool) {\n        return oracleMembers[_oracleMember] == true;\n    }\n\n    // Example Reset the reporting frequency\n    function resetEpochsPerFrame(uint32 _epochsPerFrame) external onlyDao {\n        epochsPerFrame = _epochsPerFrame;\n\n        emit ResetEpochsPerFrame(_epochsPerFrame);\n    }\n\n    // get Quorum\n    // Quorum = operatorCount * 2 / 3 + 1\n    function getQuorum() public view returns (uint32) {\n        uint32 n = uint32(getNodeOperatorsContract().getNodeOperatorsCount()) * 2 / 3;\n        return uint32(n + 1);\n    }\n\n    function getLiquidStaking() public view returns (ILiquidStaking) {\n        return ILiquidStaking(liquidStakingContract);\n    }\n\n    function getNodeOperatorsContract() public view returns (INodeOperatorsRegistry) {\n        return INodeOperatorsRegistry(nodeOperatorsContract);\n    }\n\n    function reportBeacon(uint256 _epochId, uint64 _beaconBalance, uint32 _beaconValidators, bytes32 _nodeRankingCommitment) external {\n        require(isQuorum == false, \"Quorum has been reached.\");\n        require(_isOracleMember(msg.sender), \"Not part of DAOs' trusted list of addresses\");\n        require(_epochId == expectedEpochId, \"The epoch submitted is not expected.\");\n        if (EnumerableMap.contains(hasSubmitted, msg.sender)) {\n            require(EnumerableMap.get(hasSubmitted, msg.sender) == 0, \"This msg.sender has already submitted the vote.\");\n        }\n\n        bytes32 hash = keccak256(abi.encode(_beaconBalance, _beaconValidators, _nodeRankingCommitment));\n        uint256 sameCount;\n        if (EnumerableMap.contains(submittedReports, hash)) {\n            sameCount = EnumerableMap.get(submittedReports, hash);\n        }\n        sameCount++;\n        EnumerableMap.set(submittedReports, hash, sameCount);\n\n        EnumerableMap.set(hasSubmitted, msg.sender, 1);\n        emit ReportBeacon(_epochId, msg.sender, sameCount);\n\n        uint32 quorum = getQuorum();\n        //        uint32 quorum = 3;\n        if (sameCount >= quorum) {\n            _pushReport(_beaconBalance, _beaconValidators, _nodeRankingCommitment);\n            emit ReportSuccess(_epochId, quorum, sameCount);\n        }\n    }\n\n    function isReportBeacon() external view returns (bool) {\n        if (EnumerableMap.contains(hasSubmitted, msg.sender)) {\n            return EnumerableMap.get(hasSubmitted, msg.sender) == 1;\n        }\n        return false;\n    }\n\n    function _pushReport(uint64 _beaconBalance, uint32 _beaconValidators, bytes32 _nodeRankingCommitment) private {\n        ILiquidStaking liquidStaking = getLiquidStaking();\n        liquidStaking.handleOracleReport(_beaconBalance, _beaconValidators, _nodeRankingCommitment);\n        uint256 nextExpectedEpoch = expectedEpochId + epochsPerFrame;\n\n        expectedEpochId = nextExpectedEpoch;\n        // The report passed on the same day\n        isQuorum = true;\n        beaconBalances = _beaconBalance;\n        beaconActiveValidators = _beaconValidators;\n        merkleTreeRoot = _nodeRankingCommitment;\n\n        // clear map\n        _clearReportedMap();\n    }\n\n    function _clearReportedMap() private {\n        bytes32[] memory submittedReportKeys = EnumerableMap.keys(submittedReports);\n        uint256 submittedLen = submittedReportKeys.length;\n        if (submittedLen > 0) {\n            for (uint256 i = 0; i < submittedLen; i++) {\n                EnumerableMap.remove(submittedReports, submittedReportKeys[i]);\n            }\n        }\n\n        address[] memory hasSubmittedKeys = EnumerableMap.keys(hasSubmitted);\n        uint256 hasSubmittedLen = hasSubmittedKeys.length;\n        if (hasSubmittedLen > 0) {\n            for (uint256 i = 0; i < hasSubmittedLen; i++) {\n                EnumerableMap.remove(hasSubmitted, hasSubmittedKeys[i]);\n            }\n        }\n    }\n\n    // leaf: bytes memory pubkey, uint256 validatorBalance, uint256 nftTokenID\n    function verifyNftValue(\n        bytes32[] memory proof,\n        bytes memory pubkey,\n        uint256 validatorBalance,\n        uint256 nftTokenID\n    ) external view returns (bool){\n        bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(pubkey, validatorBalance, nftTokenID))));\n        return MerkleProof.verify(proof, merkleTreeRoot, leaf);\n    }\n\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n    function _getFirstEpochOfDay(uint256 _epochId) internal view returns (uint256) {\n        return (_epochId / epochsPerFrame) * epochsPerFrame;\n    }\n\n    function _getCurrentEpochId() internal view returns (uint256) {\n        // The number of epochs after the base time\n        return (_getTime() - GENESIS_TIME) / (SLOTS_PER_EPOCH * SECONDS_PER_SLOT);\n    }\n\n    function _getTime() internal view returns (uint256) {\n        return block.timestamp;\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/oracles/BeaconOracle.sol b/src/oracles/BeaconOracle.sol
--- a/src/oracles/BeaconOracle.sol	(revision 69610968f88261a9813573e0efaefd99875a55cd)
+++ b/src/oracles/BeaconOracle.sol	(date 1673255778758)
@@ -11,11 +11,11 @@
 import "src/interfaces/INodeOperatorsRegistry.sol";
 
 /**
-  * @title Beacon Oracle and Dao
-  *
-  * BeaconOracle data acquisition and verification
-  * Dao management
-  */
+ * @title Beacon Oracle and Dao
+ *
+ * BeaconOracle data acquisition and verification
+ * Dao management
+ */
 contract BeaconOracle is
 Initializable,
 ReentrancyGuardUpgradeable,
@@ -71,7 +71,11 @@
 
     address public nodeOperatorsContract;
 
-    function initialize(address _dao, address _liquidStaking, address _nodeOperatorsContract) public initializer {
+    function initialize(
+        address _dao,
+        address _liquidStaking,
+        address _nodeOperatorsContract
+    ) public initializer {
         __UUPSUpgradeable_init();
         __ReentrancyGuard_init();
 
@@ -80,7 +84,9 @@
         nodeOperatorsContract = _nodeOperatorsContract;
         epochsPerFrame = 225;
         // So the initial is the first epochId
-        expectedEpochId = _getFirstEpochOfDay(_getCurrentEpochId()) + epochsPerFrame;
+        expectedEpochId =
+        _getFirstEpochOfDay(_getCurrentEpochId()) +
+        epochsPerFrame;
     }
 
     modifier onlyDao() {
@@ -88,25 +94,30 @@
         _;
     }
 
+    //增加oracle成员
     function addOracleMember(address _oracleMember) external onlyDao {
         oracleMembers[_oracleMember] = true;
-        oracleMemberCount ++;
+        oracleMemberCount++;
 
         emit AddOracleMember(_oracleMember);
     }
 
     function removeOracleMember(address _oracleMember) external onlyDao {
         delete oracleMembers[_oracleMember];
-        oracleMemberCount --;
+        oracleMemberCount--;
 
         emit RemoveOracleMember(_oracleMember);
     }
 
-    function isOracleMember(address _oracleMember) external view returns (bool) {
+    function isOracleMember(
+        address _oracleMember
+    ) external view returns (bool) {
         return _isOracleMember(_oracleMember);
     }
 
-    function _isOracleMember(address _oracleMember) internal view returns (bool) {
+    function _isOracleMember(
+        address _oracleMember
+    ) internal view returns (bool) {
         return oracleMembers[_oracleMember] == true;
     }
 
@@ -120,7 +131,8 @@
     // get Quorum
     // Quorum = operatorCount * 2 / 3 + 1
     function getQuorum() public view returns (uint32) {
-        uint32 n = uint32(getNodeOperatorsContract().getNodeOperatorsCount()) * 2 / 3;
+        uint32 n = (uint32(getNodeOperatorsContract().getNodeOperatorsCount()) *
+        2) / 3;
         return uint32(n + 1);
     }
 
@@ -128,19 +140,44 @@
         return ILiquidStaking(liquidStakingContract);
     }
 
-    function getNodeOperatorsContract() public view returns (INodeOperatorsRegistry) {
+    function getNodeOperatorsContract()
+    public
+    view
+    returns (INodeOperatorsRegistry)
+    {
         return INodeOperatorsRegistry(nodeOperatorsContract);
     }
 
-    function reportBeacon(uint256 _epochId, uint64 _beaconBalance, uint32 _beaconValidators, bytes32 _nodeRankingCommitment) external {
+    // oracle
+    function reportBeacon(
+        uint256 _epochId,
+        uint64 _beaconBalance,
+        uint32 _beaconValidators,
+        bytes32 _nodeRankingCommitment
+    ) external {
         require(isQuorum == false, "Quorum has been reached.");
-        require(_isOracleMember(msg.sender), "Not part of DAOs' trusted list of addresses");
-        require(_epochId == expectedEpochId, "The epoch submitted is not expected.");
+        require(
+            _isOracleMember(msg.sender),
+            "Not part of DAOs' trusted list of addresses"
+        );
+        require(
+            _epochId == expectedEpochId,
+            "The epoch submitted is not expected."
+        );
         if (EnumerableMap.contains(hasSubmitted, msg.sender)) {
-            require(EnumerableMap.get(hasSubmitted, msg.sender) == 0, "This msg.sender has already submitted the vote.");
+            require(
+                EnumerableMap.get(hasSubmitted, msg.sender) == 0,
+                "This msg.sender has already submitted the vote."
+            );
         }
 
-        bytes32 hash = keccak256(abi.encode(_beaconBalance, _beaconValidators, _nodeRankingCommitment));
+        bytes32 hash = keccak256(
+            abi.encode(
+                _beaconBalance,
+                _beaconValidators,
+                _nodeRankingCommitment
+            )
+        );
         uint256 sameCount;
         if (EnumerableMap.contains(submittedReports, hash)) {
             sameCount = EnumerableMap.get(submittedReports, hash);
@@ -154,7 +191,11 @@
         uint32 quorum = getQuorum();
         //        uint32 quorum = 3;
         if (sameCount >= quorum) {
-            _pushReport(_beaconBalance, _beaconValidators, _nodeRankingCommitment);
+            _pushReport(
+                _beaconBalance,
+                _beaconValidators,
+                _nodeRankingCommitment
+            );
             emit ReportSuccess(_epochId, quorum, sameCount);
         }
     }
@@ -166,9 +207,16 @@
         return false;
     }
 
-    function _pushReport(uint64 _beaconBalance, uint32 _beaconValidators, bytes32 _nodeRankingCommitment) private {
+    function _pushReport(
+        uint64 _beaconBalance,
+        uint32 _beaconValidators,
+        bytes32 _nodeRankingCommitment
+    ) private {
         ILiquidStaking liquidStaking = getLiquidStaking();
-        liquidStaking.handleOracleReport(_beaconBalance, _beaconValidators, _nodeRankingCommitment);
+        liquidStaking.handleOracleReport(
+            _beaconBalance,
+            _beaconValidators
+        );
         uint256 nextExpectedEpoch = expectedEpochId + epochsPerFrame;
 
         expectedEpochId = nextExpectedEpoch;
@@ -183,7 +231,9 @@
     }
 
     function _clearReportedMap() private {
-        bytes32[] memory submittedReportKeys = EnumerableMap.keys(submittedReports);
+        bytes32[] memory submittedReportKeys = EnumerableMap.keys(
+            submittedReports
+        );
         uint256 submittedLen = submittedReportKeys.length;
         if (submittedLen > 0) {
             for (uint256 i = 0; i < submittedLen; i++) {
@@ -206,24 +256,30 @@
         bytes memory pubkey,
         uint256 validatorBalance,
         uint256 nftTokenID
-    ) external view returns (bool){
-        bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(pubkey, validatorBalance, nftTokenID))));
+    ) external view returns (bool) {
+        bytes32 leaf = keccak256(
+            bytes.concat(
+                keccak256(abi.encode(pubkey, validatorBalance, nftTokenID))
+            )
+        );
         return MerkleProof.verify(proof, merkleTreeRoot, leaf);
     }
 
     function _authorizeUpgrade(address) internal override onlyOwner {}
 
-    function _getFirstEpochOfDay(uint256 _epochId) internal view returns (uint256) {
+    function _getFirstEpochOfDay(
+        uint256 _epochId
+    ) internal view returns (uint256) {
         return (_epochId / epochsPerFrame) * epochsPerFrame;
     }
 
     function _getCurrentEpochId() internal view returns (uint256) {
         // The number of epochs after the base time
-        return (_getTime() - GENESIS_TIME) / (SLOTS_PER_EPOCH * SECONDS_PER_SLOT);
+        return
+        (_getTime() - GENESIS_TIME) / (SLOTS_PER_EPOCH * SECONDS_PER_SLOT);
     }
 
     function _getTime() internal view returns (uint256) {
         return block.timestamp;
     }
-
 }
